[ MAY BE ABLE TO EMBED JUCE IN current iOS INTERFACE ]

>>>C++11 talk

* Lambdas & std::function (!!!)

-   auto lambda = [capture-list](Args a) {functionBody;}
-	std::function<void()> callback;

* JUCE value tree

- 	tree watcher: logic is reponding to property changes and triggering a flag

* std::function pass by reference or value? VALUE

-	dont pass by non-const reference
-	avoid copying

* auto: smart pointers, pitfalls

- 	don't expose raw juce::ScopePointers
- 	make them const when possible
-	use std::unique_ptr to only allow explicit stealing by invoking std::move

* keeping objects alive with reference counting

-	take reference to a safepointer (weak pointer) by capturing a weak reference BY VALUE

* std::async

-	returns a std::future which will EVENTUALLY hold the result of the function
-	std::async([&buffers]{buffers.add(loadFileInToBuffer(file.wav,wavsize))});
- 	.get() blocks until std::future value is set
-	use async and thread and future on app startpup

>>>iOS talk

> OS ramps up the clock speed if it sees the FPS failing (frames per second) => if you make some complex graphics happen, you get more CPU. 
> Apple says to code for least powerful device you want to support
> optimize DSP code with JUCE vector operations (BasicMath.h)

AUv3
> top-level stand-alone application OR AUv3 plugin
> NSApplicationGroup

Custom XCode Resource folders
	> add path of binary data

[NSURL disableBackupsForURL: ] on downloaded content

JUCE doesnt support AudioBus

since iOS 9.3.1 apple fixed the CPU scaling issue!

>>>Apple talk

* Inter-device audio mode:

-	mac osx10.11 and ios9.0

* Midi over bluetooth LE

* AUv3

>>>DAN SAKS

* USE C++ not C in embedded systems (at least try it)

* One big reason: registers (macro definitions) don't have unique typedefs, no compile time type checking

* Clustering registers into C structures is better

struct timer {
	dev_reg TMOD;
	dev_reg TDATA;
};

struct uart {
	dev_reg UARTMOD;
	dev_reg UARTDATA;
};

void timer_function(timer *one, timer *two);	

now, if we do...
timer_function(UARTMODE,TDATA);//will get compile time error

* how much does it cost to use a class instead of a structure? NOTHING
	- if you inline function calls, no CPU different
	- if you don't inline function calls, C++ is faster!

* deep-seated mistrust of abstractions :/ 

*     *(void **)0x38 = (void*)IRQ_handler;   // can work, not reliable

typedef void (*ptr_to_handler)();


** increase compile-time errors, reduce runtime errors and debugging (more coding, less interactive hardware firmware debugging)

>>>PETE GOODLIFFE

* "Learn the rules like a pro, so you can break them like an artist." -Picasso
* Audio programming is an art

* Assumptions:
-	Real-time performance application
	> DAW, synth, DJ, effect
	> NOT media player
-	C/C++ environment
* Context:
- 	observe context (CPU <-> AUDIO PROGRAM <-> BUFFER SIZES)
- 	CPU is flattening
-	multi-core CPU means you can do more (if you do the right things) -> doesn't mean we can be sloppy

* calculate coefficients on UI thread, pre-render audio buffers offline, audio analysis(vis) on different thread, amortise processing over multiple audio callbacks

* if you don't know how long it will take, don't do it => JITTER 
-	consider algorithm complexity (worst case)
-	consider data structure complexity
	- std::vector (but don't append anything on to it, could dynamically reallocate)
-	NO LOCKS: deadlock, priority inversion
- 	use lock-free, wait-free data structures
-	use atomic data
-	No memory allocation, ever (they take locks)
-	break non mem alloc rule? use custom allocation (boost::memory_pool, dlmalloc)
-	pre-allocate max memory
-	No logging (or use better logging library)
- 	No cpu calls, no Disk access (put on separate thread)
-	No network activity on audio thread (sep thread)
-	I LIKE MY OWN BUGS, NOT OTHERS BUGS

* RESPECT THREADS
-	int float bool pointer (tear-free, atomic), double long (may not be)
-	DATA LIVES ON UI THREAD

* CHOOSE RIGHT DATA REPRESENTATION
-	learn how floats work || learn how fixed point works 
-	do some fixed point stuff, will inform what you do in float domain

RAII

love all, trust a few, do wrong to none

>>>Vlad Build GUI fast

* why C++? maybe not C++ [ should evaluate other languages for GUI ]

Slider slider; // no need for ScopedPointer, then don't need slider = new Slider();

WPF (stack panels grids) and Silverlight/Prism (MVVM <= check it out)

* FlexBox

-	can create, use, and destroy within in one function, on stack, high performance

* mixing layout and graphics with application logic is bad

-	instead, model view controller (MVC)

OscillatorViewController, OscillatorView

- Views are dumb (should feel confident that throwing it away and replacing it will not affect functionality)
- Controllers deal with interaction from the view and 
- Model holds logic and State of app

* JUCE Value Trees


>>>LINN
* physical modeling
* slew attack and decay depending on attack speed/characteristics


WeAreRoli/mpejs










